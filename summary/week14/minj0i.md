# Chap 11. 노드 서비스 테스트 하기

기능이 많으면 자동화 테스트를 하기도 함

## 11.1 테스트 준비하기

jest - 페이스북에서 만든 오픈소스, 테스팅에 필요한 툴들을 대부분 갖추고 있어 편리하다

```
npm i -D jest
```

```json
// package.json
...
"scripts" : {
  "start" : "nodemon app",
  "test" : "jest"
}
```

위와같이 package.json으로 test에 jest 명령어를 지정하여 `npm test`라는 명령어로 jest를 실행 할 수 있다.  
파일명에 test나 spec이 들어간 파일들을 모두 찾아 실행함

```js
test("1 + 1은 2 입니다. ", () => {
  expoect(1 + 1).toEqual(2);
});
```

함수의 첫 번째 인수로는 테스트에 대한 설명, 두 번째 인수인 함수에는 테스트 내용을 적는다.

expect 함수의 인수로 실제 코드를, toEqual 함수의 인수로 예상되는 결괏값을 넣으면 된다.

## 11.2 유닛 테스트(Unit test)

`유닛 테스트(unit test)`: 단위 테스트라고 부르기도 함, 작은 단우의 함수나 모듈이 의도된 대로 정확히 작동하는지 테스트하는 것

가짜객체와 함수를 만들어서 넣으면 된다! 테스트의 역할은 코드나 함수가 제대로 실행되는지를 검사하고 값이 일치하는지를 검사하는 것이므로, 테스트 코드의 객체가 실제 익스프레스 객체가 아니어도 됨 => 가짜 객체, 함수를 넣는 것 `모킹(mocking)`  
함수를 모킹할 때는 jest.fn 메서드 사용.  
함수의 반환값을 지정하고 싶다면 jest.fn(() => 반환값) 을 사용

```js
expect(next).toBeCalledTimes(1);
expoct(next).toBeCalledWith(403);
```

### 미들웨어 테스트

라우터의 async 함수 부분은 따로 분리할 수 있다. controllers 폴더를 만들고 그 안에 user.js를 만든다. 라우터에서 응답을 보내는 미들웨어를 특별히 컨트롤러라고 부른다.  
실제 데이터베이스와 연결되어 있는 모델이면 테스트가 실패한다.  
따라서 모델도 모킹해야 함. `jest.mock 메서드 활용` => 코드 내에서 `User.findOne.mockReturnValue(); 활용

## 11.3 테스트 커버리지

유닛 테스트 진행 시 어떤 코드가 테스트되었는지 궁금해진다. 전체 코드 중에서 테스트되고 있는 코드의 비율과 테스트되고 있지 않은 코드의 위치를 알려주는 jest의 기능이 바로 `커버리지(coverage) 기능`

```json
// package.json
"script": {
  ...
  "coverage": "jest --coverage"
}
```

jest 명령어 뒤에 --coverage 옵션을 붙이면 jest가 테스트 커버리지를 분석함

- File (파일과 폴더 이름)
- % Stmts(구문 비율)
- % Branch(if 문 등의 분기점 비율)
- % Funcs(함수 비율)
- % Lines(코드 줄 수 비율)
- Uncovered Line #s(커버되지 않은 줄 위치)

퍼센티지가 높을수록 많은 코드가 테스트되었다는 뜻  
테스트 커버리지를 높이기보다 필요한 부분 위주로 올바르게 테스트하는 것이 더 중요

## 11.4 통합 테스트(Integration test)

라우터, 여러개의 미들웨어, 다양한 라이브러리들이 유기적으로 잘 작동하는지 테스트하는 것이 `통합테스트(integration test)`

```
npm i -D supertest
```

통합 테스트에서는 데이터베이스 코드를 모킹하지 않으므로 데이터베이스에 실제로 테스트용 데이터가 저장된다.  
실제 서비스 중인 데이터베이스에 테스트용 데이터가 들어가면 좋지 않음! 따라서 테스트용 데이터베이스 만드는 것을 추천  
config/config.json에서 test 속성을 수정함

```Console
npx sequelize db:create --env test
```

- beforeAll: 테스트를 실행하기 전에 수행되는 코드
- afterAll: 모든 테스트 끝난 후 - 보통 테스트 종료 후 데이터 정리하는 코드 추가하는 게 좋음
- beforeEach(각각의 테스트 수행 전)
- afterEach(각각의 테스트 수행 후)
- 예상되는 응답의 결과를 expect 메서드의 인수로 제공

## 11.5 부하 테스트(Load test)

서버가 얼마만큼의 요청을 견딜 수 있는지(또는 수용할 수 있는지) 테스트하는 방법  
내 코드가 실제로 배포되었을 때 어떤 문법적, 논리적 문제가 있을지는 유닛 테스트와 통합 테스트를 통해 어느 정도 확인 가능  
데표적인 문제는 OOM(Out of Memory)  
`artillery`설치하여 서버 실행해봄

```
npm i -D artillery
npm start
```

```
npx artillery quick --count 100 -n 50 http://localhost:8001
```

- Scenarios launched: 가상 사용자 생성
- Scenarios completed: 요청 완료
- Request completed: 요청 몇번 실행 됐는지
- RPS sent: 초당 요청 처리
- Request latency: 응답 지연 속도
- Scenarios counts: 총 사용자 수
- Codes: HTTP 상태 코드 => 여기서 만약 에러 발생 시 Erros 항목이 추가 됨

실제 테스트 시 실 서비스 말고 실제 서버와 같은 사양(staging server)를 만든 후 부하 테스트 진행

부하테스트 시 한 페이지 요청이 아니라 실제 사용자의 행동을 모방하여 시나리오를 작성한다. JSON 형식의 설정 파일을 작성

## 11.6 프로젝트 마무리하기

npm을 통해 설치한 패키지나 라이브러리는 그들의 몫  
이 외에도 시스템 테스트(회사에서 QA들이 목록 두고 체크해 나가는 진행 방식)와 인수 테스트(알파, 베타처럼 특정 사용자 집단이 실제 서비스를 사용하는 것처럼 진행하는 테스트)도 있다.

- 테스트 작성한다고 에러가 나는 것은 아니지만, 코드에 대한 믿음을 가질 수 있다
- 테스트 올바르게 작성하지 않으면, 안하느니만 못함
- 테스트 작성 시 나중에 코드 변경 사항 생기면 어떤 부분 영향 미칠 지 쉽게 알 수 있음 => 긍정적 영향과 테스트 공수 고려하여 테스트 범위 설정 필요
- 우선순위 정하여 우선순위대로 테스트
- 테스트 커버리지가 100% != 에러 발생
